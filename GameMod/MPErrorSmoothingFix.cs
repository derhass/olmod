using Harmony;
using Overload;
using UnityEngine;

namespace GameMod {
    public class MPErrorSmoothingFix {
        private static Vector3 savedPosition = new Vector3();
        private static Vector3 savedVelocity = new Vector3();
        private static Vector3 savedAngularVelocity = new Vector3();
        private static Quaternion savedRotation = new Quaternion();
        private static bool playerPositionOverridden = false;

        [HarmonyPatch(typeof(GameManager), "FixedUpdate")]
        class MPErrorSmoothingFix_FixedUpdateCycle {
            static void Prefix() {
                if (playerPositionOverridden) {
                    //restore the saved values
                    GameManager.m_local_player.transform.position = savedPosition;
                    GameManager.m_local_player.transform.rotation = savedRotation;
                    GameManager.m_local_player.c_player_ship.c_rigidbody.velocity = savedVelocity;
                    GameManager.m_local_player.c_player_ship.c_rigidbody.angularVelocity = savedAngularVelocity;
                    playerPositionOverridden = false;
                }
            }
            static void Postfix() {
                // only on the Client, in Multiplayer, in an active game, not during death roll:
                if (!Server.IsActive() && GameplayManager.IsMultiplayerActive && NetworkMatch.InGameplay() && !GameManager.m_local_player.c_player_ship.m_dying) {
                    // Save the current ship sate.
                    // This is the one synced with the server, and with the
                    // error smoothing applied to it already.
                    savedPosition = GameManager.m_local_player.transform.position;
                    savedRotation = GameManager.m_local_player.transform.rotation;
                    savedVelocity = GameManager.m_local_player.c_player_ship.c_rigidbody.velocity;
                    savedAngularVelocity = GameManager.m_local_player.c_player_ship.c_rigidbody.angularVelocity;

                    // Simulate one physics tick more for the player object (and effectively, also for the camera).
                    // Note that m_local_player.c_player_ship.c_rigidbody.interpolation = Interpolate is set,
                    // which normally results in the data being interpolated per frame which gets rendered.
                    // However, this seems to only work with data generated by two consecutive  physics simulation ticks.
                    // Since the error smoothing is applied _after_ the physics simulation, this interpolation does not
                    // work anymore, so if error smoothing was done, the user's ship and camera is moved only at each
                    // fixed time step (60Hz in multiplayer), no matter how high the framerate is.
                    //
                    // We fix this by doing one more physics interpolation step for the player ship.
                    // Note we do this uncoditionally no matter whether error smoothing was applied or not, to
                    // get consistently one frame ahead. When the Interpolate mode is selected,
                    // it will effectively delay the results by one physics tick,, so being one frame ahead is
                    // actually more close to the truth, and will result in a slightly more direct input feeling,
                    // since we effectively do some sort of extrapolation now.
                    //
                    // Note that this change is local to the client only, and only during the rendering cycles
                    // which follow until we reach the next FixedUpdate cycle, where we  undo the changes right at
                    // the beginning.
                    NetworkSim.PauseAllRigidBodiesExcept(GameManager.m_local_player.c_player_ship.c_rigidbody);
                    NetworkSim.m_resimulating = true; // this disables some collision handling of the player ship
                    Physics.Simulate(Time.fixedDeltaTime);
                    NetworkSim.m_resimulating = false;
                    NetworkSim.ResumeAllPausedRigidBodies();

                    // we need to restore the orginal values in the next cycle...
                    playerPositionOverridden = true;
                }
            }
        }
    }
}
