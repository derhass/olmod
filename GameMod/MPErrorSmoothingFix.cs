using Harmony;
using Overload;
using System.Collections.Generic;
using UnityEngine;

namespace GameMod {
    public class MPErrorSmoothingFix {
        private static Vector3 savedPosition = new Vector3();
        private static Vector3 savedVelocity = new Vector3();
        private static Vector3 savedAngularVelocity = new Vector3();
        private static Quaternion savedRotation = new Quaternion();
        private static bool playerPositionOverridden = false;
        private static int hackIsEnabled = 0;

        private static void hack_smooth_command() {
                int n = uConsole.GetNumParameters();
                if (n > 0) {
                        int value = uConsole.GetInt();
                        hackIsEnabled = value;
                } else {
                        hackIsEnabled = (hackIsEnabled >0)?0:1;
                }
                UnityEngine.Debug.LogFormat("hack_smooth is now {0}", hackIsEnabled);
        }

        [HarmonyPatch(typeof(GameManager), "Awake")]
        class MPErrorSmoothingFix_Controller {
            static void Postfix() {
                uConsole.RegisterCommand("hack_smooth", hack_smooth_command);
            }
        }

        [HarmonyPatch(typeof(GameManager), "FixedUpdate")]
        class MPErrorSmoothingFix_FixedUpdateCycle {
            static void Prefix() {
                if (playerPositionOverridden) {
                    //restore the saved values
                    GameManager.m_local_player.transform.position = savedPosition;
                    GameManager.m_local_player.transform.rotation = savedRotation;
                    GameManager.m_local_player.c_player_ship.c_rigidbody.velocity = savedVelocity;
                    GameManager.m_local_player.c_player_ship.c_rigidbody.angularVelocity = savedAngularVelocity;
                    playerPositionOverridden = false;
                }
            }
            static void Postfix() {
                // only on the Client, in Multiplayer, in an active game, not during death roll:
                if ((hackIsEnabled>0) && !Server.IsActive() && GameplayManager.IsMultiplayerActive && NetworkMatch.InGameplay() && !GameManager.m_local_player.c_player_ship.m_dying) {
                    // Save the current ship sate.
                    // This is the one synced with the server, and with the
                    // error smoothing applied to it already.
                    savedPosition = GameManager.m_local_player.transform.position;
                    savedRotation = GameManager.m_local_player.transform.rotation;
                    savedVelocity = GameManager.m_local_player.c_player_ship.c_rigidbody.velocity;
                    savedAngularVelocity = GameManager.m_local_player.c_player_ship.c_rigidbody.angularVelocity;

                    // Simulate one physics tick more for the player object (and effectively, also for the camera).
                    // Note that m_local_player.c_player_ship.c_rigidbody.interpolation = Interpolate is set,
                    // which normally results in the data being interpolated per frame which gets rendered.
                    // However, this seems to only work with data generated by two consecutive  physics simulation ticks.
                    // Since the error smoothing is applied _after_ the physics simulation, this interpolation does not
                    // work anymore, so if error smoothing was done, the user's ship and camera is moved only at each
                    // fixed time step (60Hz in multiplayer), no matter how high the framerate is.
                    //
                    // We fix this by doing one more physics interpolation step for the player ship.
                    // Note we do this uncoditionally no matter whether error smoothing was applied or not, to
                    // get consistently one frame ahead. When the Interpolate mode is selected,
                    // it will effectively delay the results by one physics tick,, so being one frame ahead is
                    // actually more close to the truth, and will result in a slightly more direct input feeling,
                    // since we effectively do some sort of extrapolation now.
                    //
                    // Note that this change is local to the client only, and only during the rendering cycles
                    // which follow until we reach the next FixedUpdate cycle, where we  undo the changes right at
                    // the beginning.
                    int cnt = 0;
                    foreach (KeyValuePair<Rigidbody, RigidBodyState> paused_rigid_body in NetworkSim.m_paused_rigid_bodies) {
                        cnt++;
                    }

                    UnityEngine.Debug.LogFormat("XXX cnt {0}, msim {1}", cnt,NetworkSim.m_resimulating);

                    if (hackIsEnabled < 3) {
                        NetworkSim.PauseAllRigidBodiesExcept(GameManager.m_local_player.c_player_ship.c_rigidbody);
                    }
                    NetworkSim.m_resimulating = true; // this disables some collision handling of the player ship
                    if (hackIsEnabled < 2) {
                        Physics.Simulate(Time.fixedDeltaTime);
                    }
                    NetworkSim.m_resimulating = false;
                    if (hackIsEnabled < 4) {
                        NetworkSim.ResumeAllPausedRigidBodies();
                    }

                    // we need to restore the orginal values in the next cycle...
                    if (hackIsEnabled < 2) { 
                        playerPositionOverridden = true;
                    }
                }
            }
        }
    }
}
